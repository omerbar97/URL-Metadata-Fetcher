class Collectable<T> {
  public props = {};
  public value: T;

  constructor(value: T, props = {}) {
    this.value = value;
    this.props = props;
  }

  prop(key) {
    return this.props[key];
  }

  check(key:string, value:(any[]|any)) {
    if (!(value instanceof Array)) {
      value = [value];
    }

    for (let i = 0; i < value.length; i++) {
      if (this.prop(key) === value[i]) {
        return this;
      }
    }

    return null;
  }

  checkAll(props) {
    for (let key in props) {
      if (this.check(key, props[key]) === null) {
        return null;
      }
    }

    return this;
  }
}

interface CollectionIterator<T> {
  (collectable: Collectable<T>, item: T): void
}

class Collection<T> {
  private items: Array<Collectable<T>>;

  constructor(initial: Array<Collectable<T>> = []) {
    this.items = initial;
  }

  filter(props):Collection<T> {
    const filtered = this.items.filter((collectable => {
      return collectable.checkAll(props);
    }).bind(this));

    return new Collection<T>(filtered);
  }

  map(callback: CollectionIterator<T>) {
    return this.items.map(((item) => {
      callback.bind(this)(item, item.value);
    }).bind(this));
  }

  push(item: (T|Collectable<T>), props = {}) {
    if (item instanceof Collectable) {
      this.items.push(item);
    } else {
      this.items.push(new Collectable<T>(item, props));
    }
  }

  pull(start: number = 0) {
    return this.items.splice(start, 1)[0].value;
  }

  reverse() {
    return new Collection<T>(this.items.reverse());
  }

  count():number {
    return this.items.length;
  }
}


export default Collection;
export { Collectable, Collection }
